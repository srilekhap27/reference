// Function to handle searching based on the provided search parameters
const handleSearch = async (e) => {
  e.preventDefault(); // Prevent default form submission behavior

  console.log("Calling handleSearch");

  try {
    // Check if any of the required search fields are empty
    if (!sourceObject && !actionObject && !errornameObject) {
      setFilterErrorMessage("Any one field is required to submit.");
      return;
    }

    // Ensure the length of each search parameter is valid (>= 4 characters)
    if (
      (sourceObject && sourceObject.length < 4) ||
      (actionObject && actionObject.length < 4) ||
      (errornameObject && errornameObject.length < 4)
    ) {
      setFilterErrorMessage("Please enter at least 4 characters");
      return;
    }

    // Fetch all records from the API (similar to retrieveRecords)
    let res = await getAllRecords(null);

    if (res.status === 200) {
      let data = JSON.parse(res.data.body); // Parse the response body
      let objects = data.objects; // Get the records

      // Set "isMoreData" state based on the continuation token
      setIsMoreData(
        data.nextContinuationToken !== undefined &&
        data.nextContinuationToken.length > 0
      );

      // Start count from the length of the existing records
      let startCount = records.length + 1;

      // Process the objects array and apply filtering logic
      let results = objects.map((entry) => {
        let [source, action, docName] = entry.split('/');

        // Check if the record matches the search criteria
        const sourceMatches = sourceObject && source.includes(sourceObject);
        const actionMatches = actionObject && action.includes(actionObject);
        const errornameMatches = errornameObject && docName.includes(errornameObject);

        // Matching logic with if conditions
        if (sourceMatches && actionMatches && errornameMatches) {
          console.log("Source, Action, and Erroname matched");
          return createRecord(startCount++, source, action, docName, entry);
        } else if (sourceMatches && actionMatches) {
          console.log("Source and Action matched");
          return createRecord(startCount++, source, action, docName, entry);
        } else if (actionMatches && errornameMatches) {
          console.log("Action and Erroname matched");
          return createRecord(startCount++, source, action, docName, entry);
        } else if (sourceMatches && errornameMatches) {
          console.log("Source and Erroname matched");
          return createRecord(startCount++, source, action, docName, entry);
        } else if (sourceMatches) {
          console.log("Source matched");
          return createRecord(startCount++, source, action, docName, entry);
        } else if (actionMatches) {
          console.log("Action matched");
          return createRecord(startCount++, source, action, docName, entry);
        } else if (errornameMatches) {
          console.log("Erroname matched");
          return createRecord(startCount++, source, action, docName, entry);
        }

        return null; // If no match, return null (we will filter these out)
      }).filter(record => record !== null); // Filter out any null values (no matches)

      // Handle no matches found
      if (results.length === 0) {
        setFilterErrorMessage("No records matched your search criteria.");
        setRecords([]);  // Clear the records state
        setIsMoreData(false);  // Indicate no more data
      } else {
        // Combine existing records with the new search results
        let combined = [...records, ...results];  // Merge old records and new results

        // Update the state with combined records
        setRecords(combined);

        // Clear any error message if the search was successful
        setFilterErrorMessage(""); 
      }
    } else {
      // Handle non-200 responses
      setFilterErrorMessage("Error fetching records.");
    }
  } catch (error) {
    // Handle errors during the network request
    console.error("Error fetching records: Network error", error);
    setFilterErrorMessage("Error fetching records: Network error");
  }
};

// Helper function to create a record based on the search criteria
const createRecord = (startCount, source, action, docName, entry) => {
  let unix = convertUnixToDate(docName.split('_').pop()); // Convert the timestamp
  let date = new Date(unix);
  let dateString = date.toUTCString(); // Convert the date to a string format

  return [
    startCount,    // Record count
    false,         // Some flag or status (adjust if necessary)
    docName,       // Document name
    source,        // Source
    dateString,    // Date string
    action,        // Action
    entry          // The full entry object
  ];
};
